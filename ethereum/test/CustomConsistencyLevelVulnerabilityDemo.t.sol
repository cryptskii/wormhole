// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "../contracts/custom_consistency_level/CustomConsistencyLevel.sol";
import "../contracts/custom_consistency_level/interfaces/ICustomConsistencyLevel.sol";

/// Minimal harness that emulates the *original vulnerable* behavior (no masking).
contract VulnerableCustomConsistencyLevelHarness is ICustomConsistencyLevel {
    mapping(address => bytes32) private _cfg;

    function configure(bytes32 config) external override {
        _cfg[msg.sender] = config;           // stores unsanitized bits
        emit ConfigSet(msg.sender, config);  // emits unsanitized config
    }

    function getConfiguration(address emitter) external view override returns (bytes32) {
        return _cfg[emitter];
    }
}

/// @notice Isolated tests: prove the bug on the harness, prove the fix on the real contract.
contract CustomConsistencyLevelIsolatedTest is Test {
    // Canonical field layout (must match the real contract)
    uint256 constant SHIFT_VERSION     = 248; // [255:248]  8 bits
    uint256 constant SHIFT_CONSISTENCY = 240; // [247:240]  8 bits
    uint256 constant SHIFT_BLOCKS      = 224; // [239:224] 16 bits

    // Reserved region = [223:0]
    uint256 constant RESERVED_WIDTH     = 224;
    uint256 constant RESERVED_MASK      = (uint256(1) << RESERVED_WIDTH) - 1;
    uint256 constant SHIFT_RSVD_TOPBYTE = 216; // [223:216] top reserved byte

    address emitter = address(0x123);

    CustomConsistencyLevel realDefended;                 // the fixed implementation
    VulnerableCustomConsistencyLevelHarness vulnerable;  // the vulnerable harness

    function setUp() public {
        realDefended = new CustomConsistencyLevel();
        vulnerable   = new VulnerableCustomConsistencyLevelHarness();
    }

    // ---------- Helpers ----------
    function _pack(uint8 ver, uint8 cons, uint16 blocks) internal pure returns (bytes32) {
        return bytes32(
            (uint256(ver)    << SHIFT_VERSION)     |
            (uint256(cons)   << SHIFT_CONSISTENCY) |
            (uint256(blocks) << SHIFT_BLOCKS)
        );
    }

    // ---------- Vulnerability demo on the harness ----------
    function test_VulnDemo_ReservedBitsPersist_OnHarness() public {
        uint8  version = 1;
        uint8  cons    = 200;
        uint16 blocks  = 10;
        uint8  junk    = 0xAA; // malicious reserved bits

        bytes32 polluted = _pack(version, cons, blocks)
            | bytes32(uint256(junk) << SHIFT_RSVD_TOPBYTE);

        vm.prank(emitter);
        vulnerable.configure(polluted);

        bytes32 stored = vulnerable.getConfiguration(emitter);

        // Bug: reserved bits persist
        uint8 storedReserved = uint8(uint256(stored >> SHIFT_RSVD_TOPBYTE));
        assertEq(storedReserved, junk, "VULN: reserved bits persist in storage");

        // Downstream decode pitfall: 24-bit misdecode inflates value (0x0A -> 0x0AAA)
        uint16 correctDecode = uint16(uint256(stored >> SHIFT_BLOCKS));
        uint24 buggyDecode   = uint24(uint256(stored >> SHIFT_RSVD_TOPBYTE));
        assertEq(correctDecode, blocks, "16-bit decode should match intended blocks");
        assertEq(buggyDecode, (uint24(blocks) << 8) | junk, "24-bit decode inflated by reserved bits");
        assertTrue(buggyDecode > correctDecode, "Inflation confirmed (10 -> 2730)");
    }

    // ---------- Defense-in-depth: the *real* defended contract must reject reserved bits ----------
    function test_Defense_ShouldRejectReservedBits_OnRealContract() public {
        bytes32 withReserved = bytes32(uint256(0xFF) << SHIFT_RSVD_TOPBYTE);

        vm.prank(emitter);
        // If the contract defines a custom error, prefer its selector:
        // vm.expectRevert(CustomConsistencyLevel.InvalidReservedBits.selector);
        vm.expectRevert();
        realDefended.configure(withReserved);
    }

    function test_CleanConfiguration_Accepted_OnRealContract() public {
        bytes32 clean = _pack(1, 200, 10);

        vm.prank(emitter);
        realDefended.configure(clean);

        bytes32 stored = realDefended.getConfiguration(emitter); // or configurationOf(emitter) if thatâ€™s the name in your impl
        assertEq(stored, clean, "stored must equal clean config");

        // Reserved region must be zero on storage
        uint256 lower224 = uint256(stored) & RESERVED_MASK;
        assertEq(lower224, 0, "All reserved bits [223:0] must be zero");

        // Sanity on fields
        assertEq(uint8(uint256(stored >> SHIFT_VERSION)), 1);
        assertEq(uint8(uint256(stored >> SHIFT_CONSISTENCY)), 200);
        assertEq(uint16(uint256(stored >> SHIFT_BLOCKS)), 10);
    }
}